import { errorClassWithData, errorClass } from "error-kid";
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
// @__NO_SIDE_EFFECTS__
function N(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
// @__NO_SIDE_EFFECTS__
function Z(e) {
  return void 0;
}
// @__NO_SIDE_EFFECTS__
function ee(e) {
  return void 0;
}
// @__NO_SIDE_EFFECTS__
function ne(e, n) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(n);
}
// @__NO_SIDE_EFFECTS__
function re(e) {
  var r, t;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? "null" : n;
}
function f(e, n, r, t, s) {
  const u = s && "input" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {
    kind: e.kind,
    type: e.type,
    input: u,
    expected: i,
    received: l,
    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : "R"}eceived ${l}`,
    requirement: e.requirement,
    path: s == null ? void 0 : s.path,
    issues: s == null ? void 0 : s.issues,
    lang: t.lang,
    abortEarly: t.abortEarly,
    abortPipeEarly: t.abortPipeEarly
  }, y = e.kind === "schema", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);
  p && (o.message = typeof p == "function" ? (
    // @ts-expect-error
    p(o)
  ) : p), y && (r.typed = false), r.issues ? r.issues.push(o) : r.issues = [o];
}
// @__NO_SIDE_EFFECTS__
function h(e) {
  return {
    version: 1,
    vendor: "valibot",
    validate(n) {
      return e["~run"]({ value: n }, /* @__PURE__ */ N());
    }
  };
}
// @__NO_SIDE_EFFECTS__
function W(e, n) {
  return Object.hasOwn(e, n) && n !== "__proto__" && n !== "prototype" && n !== "constructor";
}
// @__NO_SIDE_EFFECTS__
function te(e, n) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? "never";
}
var se = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), this.name = "ValiError", this.issues = e;
  }
};
// @__NO_SIDE_EFFECTS__
function R(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: R,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    "~run"(n, r) {
      return n.typed && !this.requirement(n.value) && f(this, "integer", n, r), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function d(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: d,
    async: false,
    operation: e,
    "~run"(n) {
      return n.value = this.operation(n.value), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function U(e, n, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(n, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
// @__NO_SIDE_EFFECTS__
function _(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: _,
    expects: "boolean",
    async: false,
    message: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      return typeof n.value == "boolean" ? n.typed = true : f(this, "type", n, r), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function z(e) {
  return {
    kind: "schema",
    type: "date",
    reference: z,
    expects: "Date",
    async: false,
    message: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      return n.value instanceof Date ? isNaN(n.value) ? f(this, "type", n, r, {
        received: '"Invalid Date"'
      }) : n.typed = true : f(this, "type", n, r), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function J(e, n) {
  return {
    kind: "schema",
    type: "instance",
    reference: J,
    expects: e.name,
    async: false,
    class: e,
    message: n,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(r, t) {
      return r.value instanceof this.class ? r.typed = true : f(this, "type", r, t), r;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function A(e) {
  return {
    kind: "schema",
    type: "lazy",
    reference: A,
    expects: "unknown",
    async: false,
    getter: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      return this.getter(n.value)["~run"](n, r);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function k(e, n) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: k,
    expects: "Object",
    async: false,
    entries: e,
    message: n,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(r, t) {
      var u;
      const s = r.value;
      if (s && typeof s == "object") {
        r.typed = true, r.value = {};
        for (const i in this.entries) {
          const l = this.entries[i];
          if (i in s || (l.type === "exact_optional" || l.type === "optional" || l.type === "nullish") && // @ts-expect-error
          l.default !== void 0) {
            const o = i in s ? (
              // @ts-expect-error
              s[i]
            ) : /* @__PURE__ */ U(l), y = l["~run"]({ value: o }, t);
            if (y.issues) {
              const p = {
                type: "object",
                origin: "value",
                input: s,
                key: i,
                value: o
              };
              for (const m of y.issues)
                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);
              if (r.issues || (r.issues = y.issues), t.abortEarly) {
                r.typed = false;
                break;
              }
            }
            y.typed || (r.typed = false), r.value[i] = y.value;
          } else if (l.type !== "exact_optional" && l.type !== "optional" && l.type !== "nullish" && (f(this, "key", r, t, {
            input: void 0,
            expected: `"${i}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: s,
                key: i,
                // @ts-expect-error
                value: s[i]
              }
            ]
          }), t.abortEarly))
            break;
        }
        if (!r.issues || !t.abortEarly)
          for (const i in s)
            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);
      } else
        f(this, "type", r, t);
      return r;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function E(e) {
  return {
    kind: "schema",
    type: "number",
    reference: E,
    expects: "number",
    async: false,
    message: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      return typeof n.value == "number" && !isNaN(n.value) ? n.typed = true : f(this, "type", n, r), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function c(e, n) {
  return {
    kind: "schema",
    type: "optional",
    reference: c,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    default: n,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(r, t) {
      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = true, r) : this.wrapped["~run"](r, t);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function a(e) {
  return {
    kind: "schema",
    type: "string",
    reference: a,
    expects: "string",
    async: false,
    message: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      return typeof n.value == "string" ? n.typed = true : f(this, "type", n, r), n;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function O(e) {
  let n;
  if (e)
    for (const r of e)
      n ? n.push(...r.issues) : n = r.issues;
  return n;
}
// @__NO_SIDE_EFFECTS__
function $(e, n) {
  return {
    kind: "schema",
    type: "union",
    reference: $,
    expects: /* @__PURE__ */ te(
      e.map((r) => r.expects),
      "|"
    ),
    async: false,
    options: e,
    message: n,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(r, t) {
      let s, u, i;
      for (const l of this.options) {
        const o = l["~run"]({ value: r.value }, t);
        if (o.typed)
          if (o.issues)
            u ? u.push(o) : u = [o];
          else {
            s = o;
            break;
          }
        else
          i ? i.push(o) : i = [o];
      }
      if (s)
        return s;
      if (u) {
        if (u.length === 1)
          return u[0];
        f(this, "type", r, t, {
          issues: /* @__PURE__ */ O(u)
        }), r.typed = true;
      } else {
        if ((i == null ? void 0 : i.length) === 1)
          return i[0];
        f(this, "type", r, t, {
          issues: /* @__PURE__ */ O(i)
        });
      }
      return r;
    }
  };
}
function B(e, n, r) {
  const t = e["~run"]({ value: n }, /* @__PURE__ */ N(r));
  if (t.issues)
    throw new se(t.issues);
  return t.value;
}
// @__NO_SIDE_EFFECTS__
function v(...e) {
  return {
    ...e[0],
    pipe: e,
    get "~standard"() {
      return /* @__PURE__ */ h(this);
    },
    "~run"(n, r) {
      for (const t of e)
        if (t.kind !== "metadata") {
          if (n.issues && (t.kind === "schema" || t.kind === "transformation")) {
            n.typed = false;
            break;
          }
          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t["~run"](n, r));
        }
      return n;
    }
  };
}
function ue(e) {
  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());
}
function ae(e) {
  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});
}
function w(e) {
  const n = ae(e);
  for (const r in n) {
    const t = n[r];
    t && typeof t == "object" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));
  }
  return n;
}
function I(e) {
  return /* @__PURE__ */ d((n) => e ? w(n) : n);
}
function M(e) {
  return (n) => /* @__PURE__ */ v(
    e,
    I(n)
  );
}
function T(e) {
  return (n, r) => B(
    /* @__PURE__ */ v(e, I(r)),
    n
  );
}
function oe() {
  return /* @__PURE__ */ d(JSON.parse);
}
function C(e) {
  const n = M(e);
  return (r) => /* @__PURE__ */ v(
    /* @__PURE__ */ a(),
    oe(),
    n(r)
  );
}
function ce(e) {
  return /* @__PURE__ */ d((n) => {
    const r = {};
    return new URLSearchParams(n).forEach((t, s) => {
      const u = r[s];
      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];
    }), B(e, r);
  });
}
function K(e) {
  return (n) => /* @__PURE__ */ v(
    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),
    ce(e),
    I(n)
  );
}
const Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({
  id: /* @__PURE__ */ E(),
  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  type: /* @__PURE__ */ a(),
  title: /* @__PURE__ */ a(),
  username: /* @__PURE__ */ c(/* @__PURE__ */ a())
}), pe = /* @__PURE__ */ k({
  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),
  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),
  first_name: /* @__PURE__ */ a(),
  id: /* @__PURE__ */ E(),
  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),
  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),
  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  username: /* @__PURE__ */ c(/* @__PURE__ */ a())
}), fe = /* @__PURE__ */ k({
  auth_date: /* @__PURE__ */ v(
    /* @__PURE__ */ a(),
    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),
    /* @__PURE__ */ z()
  ),
  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),
  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),
  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  hash: /* @__PURE__ */ a(),
  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  receiver: Q,
  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),
  signature: /* @__PURE__ */ a(),
  user: Q
}), ye = C(le), he = C(pe), F = K(fe);
const ke = T(F());
function Y(e, n) {
  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(
    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([
      t,
      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == "string" || typeof s == "number" ? String(s) : typeof s == "boolean" ? s ? "1" : "0" : n(t, s)
    ]), r), [])
  ).toString();
}
function ve(e) {
  return Y(e);
}
function sign(data, key, authDate, signData2, options) {
  const searchParams = new URLSearchParams(
    ve({
      ...data,
      auth_date: authDate,
      hash: "",
      signature: data.signature || ""
    })
  );
  searchParams.delete("hash");
  const pairs = [...searchParams.entries()].map(([name, value]) => `${name}=${value}`).sort();
  function processSign2(s) {
    searchParams.append("hash", s);
    return searchParams.toString();
  }
  const sign2 = signData2(pairs.join("\n"), key, options);
  return typeof sign2 === "string" ? processSign2(sign2) : sign2.then(processSign2);
}
function arrayBufferToHex(buffer) {
  return new Uint8Array(buffer).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error("Hex string must have an even number of characters");
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return buffer;
}
function signData(data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : key : hashToken(key, createHmac);
  if (keyHmac instanceof Promise) {
    return keyHmac.then((v2) => createHmac(data, v2)).then(arrayBufferToHex);
  }
  const hmac = createHmac(data, keyHmac);
  return hmac instanceof Promise ? hmac.then(arrayBufferToHex) : arrayBufferToHex(hmac);
}
const [
  AuthDateInvalidError,
  isAuthDateInvalidError
] = errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
);
const [
  SignatureInvalidError,
  isSignatureInvalidError
] = errorClass("SignatureInvalidError");
const [
  SignatureMissingError,
  isSignatureMissingError
] = errorClass("SignatureMissingError", (thirdParty) => [
  `"${thirdParty ? "signature" : "hash"}" parameter is missing`
]);
const [
  ExpiredError,
  isExpiredError
] = errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
);
function processSign(actual, expected) {
  if (actual !== expected) {
    throw new SignatureInvalidError();
  }
  return;
}
function validate(value, token, signData2, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    throw new SignatureMissingError(false);
  }
  if (!authDate) {
    throw new AuthDateInvalidError(authDateString);
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));
    }
  }
  pairs.sort();
  const sign2 = signData2(pairs.join("\n"), token, options);
  return typeof sign2 === "string" ? processSign(sign2, hash) : sign2.then((v2) => processSign(v2, hash));
}
function isValid(value, token, validate2, options) {
  try {
    const maybePromise = validate2(value, token, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
function processResult(verified) {
  if (!verified) {
    throw new SignatureInvalidError();
  }
  return;
}
function validate3rd$1(value, botId, verify, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    throw new SignatureMissingError(true);
  }
  if (!authDate) {
    throw new AuthDateInvalidError(authDateString);
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));
    }
  }
  const verified = verify(
    `${botId}:WebAppData
${pairs.sort().join("\n")}`,
    options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
    signature
  );
  return typeof verified === "boolean" ? processResult(verified) : verified.then(processResult);
}
function isValid3rd$1(value, botId, validate2, options) {
  try {
    const maybePromise = validate2(value, botId, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
const parse = ke;
const verify3rd = async (data, key, signature) => {
  return crypto.subtle.verify(
    "Ed25519",
    await crypto.subtle.importKey("raw", Buffer.from(key, "hex"), "Ed25519", false, ["verify"]),
    Buffer.from(signature, "base64"),
    Buffer.from(data)
  );
};
async function validate3rd(value, botId, options) {
  return validate3rd$1(value, botId, verify3rd, options);
}
function isValid3rd(value, botId, options) {
  return isValid3rd$1(value, botId, validate3rd, options);
}
export {
  AuthDateInvalidError as A,
  ExpiredError as E,
  SignatureMissingError as S,
  signData as a,
  validate3rd as b,
  isValid3rd as c,
  SignatureInvalidError as d,
  isSignatureMissingError as e,
  isAuthDateInvalidError as f,
  isExpiredError as g,
  hashToken as h,
  isValid as i,
  isSignatureInvalidError as j,
  parse as p,
  sign as s,
  validate as v
};
//# sourceMappingURL=shared-cWQiAT7_.js.map
