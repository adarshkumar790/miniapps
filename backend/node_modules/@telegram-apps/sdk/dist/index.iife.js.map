{"version":3,"file":"index.iife.js","sources":["../../bridge/dist/index.js","../../toolkit/dist/index.js","../../navigation/dist/index.js","../../signals/dist/index.js","../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../../../node_modules/.pnpm/error-kid@0.0.4/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../../../node_modules/.pnpm/better-promises@0.4.0/node_modules/better-promises/dist/index.js","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/scopes/components/location-manager/location-manager.ts","../src/utils/removeUndefined.ts","../../transformers/dist/index.js","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/copyTextToClipboard.ts","../src/scopes/utilities/uncategorized/downloadFile.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareMessage.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["var E;\n// @__NO_SIDE_EFFECTS__\nfunction ke(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? (E == null ? void 0 : E.lang),\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? (E == null ? void 0 : E.abortEarly),\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? (E == null ? void 0 : E.abortPipeEarly)\n  };\n}\nvar C;\n// @__NO_SIDE_EFFECTS__\nfunction rt(t) {\n  return C == null ? void 0 : C.get(t);\n}\nvar U;\n// @__NO_SIDE_EFFECTS__\nfunction st(t) {\n  return U == null ? void 0 : U.get(t);\n}\nvar O;\n// @__NO_SIDE_EFFECTS__\nfunction it(t, e) {\n  var n;\n  return (n = O == null ? void 0 : O.get(t)) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction at(t) {\n  var n, r;\n  const e = typeof t;\n  return e === \"string\" ? `\"${t}\"` : e === \"number\" || e === \"bigint\" || e === \"boolean\" ? `${t}` : e === \"object\" || e === \"function\" ? (t && ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null ? void 0 : r.name)) ?? \"null\" : e;\n}\nfunction A(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ at(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ it(t.reference, o.lang) ?? (c ? /* @__PURE__ */ st(o.lang) : null) ?? r.message ?? /* @__PURE__ */ rt(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ ke());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ot(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\nvar ut = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction X(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction xe() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: xe,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: G,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: V,\n    expects: \"Function\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"function\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: v,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      var a;\n      const s = n.value;\n      if (s && typeof s == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in s || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ X(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (a = n.issues) == null || a.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (A(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ ot(s, i) && !(i in this.entries) && (n.value[i] = s[i]);\n      } else\n        A(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: T,\n    expects: `(${t.expects} | null | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return (n.value === null || n.value === void 0) && (this.default !== void 0 && (n.value = /* @__PURE__ */ X(this, n, r)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: B,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction F(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: F,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ X(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: k,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction $e() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: $e,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction K(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ ke(n));\n  if (r.issues)\n    throw new ut(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Pe(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction Se(t) {\n  return /* @__PURE__ */ D(\n    /* @__PURE__ */ v({ TelegramWebviewProxy: /* @__PURE__ */ v({ postEvent: /* @__PURE__ */ V() }) }),\n    t\n  );\n}\nfunction je() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar ct = Object.defineProperty, pt = (t, e, n) => e in t ? ct(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, pe = (t, e, n) => pt(t, typeof e != \"symbol\" ? e + \"\" : e, n);\nfunction lt(t) {\n  return (e) => e instanceof t;\n}\nfunction Ae(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, lt(n)];\n}\nconst [ft, cn] = Ae(\"CancelledError\", \"Promise was canceled\"), [dt, pn] = Ae(\n  \"TimeoutError\",\n  (t, e) => [`Timeout reached: ${t}ms`, { cause: e }]\n), qe = Symbol(\"Resolved\");\nfunction le(t) {\n  return Array.isArray(t) && t[0] === qe;\n}\nfunction _t(t) {\n  return [qe, t];\n}\nfunction fe(t, e) {\n  return t.reject = e.reject, t.abort = e.abort, t;\n}\nlet Me = class Y extends Promise {\n  constructor(e, n) {\n    let r, s;\n    super((a, i) => {\n      let u, o;\n      typeof e == \"function\" ? (u = e, o = n) : o = e;\n      const c = [], p = (f) => (...j) => {\n        const I = f(...j);\n        return c.forEach((nt) => nt()), I;\n      }, l = new AbortController(), { signal: y } = l;\n      s = (f) => {\n        !y.aborted && l.abort(f);\n      };\n      const b = () => y.reason, P = (f) => {\n        const j = () => {\n          f(b());\n        };\n        y.addEventListener(\"abort\", j, !0);\n        const I = () => {\n          y.removeEventListener(\"abort\", j, !0);\n        };\n        return c.push(I), I;\n      }, tt = p((f) => {\n        a(f), s(_t(f));\n      });\n      r = p((f) => {\n        i(f), s(f);\n      }), o || (o = {});\n      const { abortSignal: S, rejectOnAbort: ae = !0 } = o;\n      if (S)\n        if (S.aborted) {\n          const { reason: f } = S;\n          if (ae)\n            return r(f);\n          s(f);\n        } else {\n          const f = () => {\n            s(S.reason);\n          };\n          S.addEventListener(\"abort\", f), c.push(() => {\n            S.removeEventListener(\"abort\", f);\n          });\n        }\n      ae && P(i);\n      const { timeout: N } = o;\n      if (N) {\n        const f = setTimeout(() => {\n          s(new dt(N));\n        }, N);\n        c.push(() => {\n          clearTimeout(f);\n        });\n      }\n      const oe = () => y.aborted, ue = () => le(b()), ce = () => {\n        const f = b();\n        return le(f) ? f[1] : void 0;\n      };\n      try {\n        const f = u && u(tt, r, {\n          abortReason: b,\n          abortSignal: y,\n          isAborted: oe,\n          isResolved: ue,\n          onAborted: P,\n          onResolved: (j) => P(() => {\n            ue() && j(ce());\n          }),\n          resolved: ce,\n          throwIfAborted() {\n            if (oe())\n              throw b();\n          }\n        });\n        f instanceof Promise && f.catch(r);\n      } catch (f) {\n        r(f);\n      }\n    }), pe(this, \"abort\"), pe(this, \"reject\"), this.abort = s, this.reject = r;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new Y(async (r, s, a) => {\n      try {\n        r(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new Y((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new ft());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return fe(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return fe(super.then(e, n), this);\n  }\n};\nfunction yt(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction bt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[yt(n)] = r, e), {});\n}\nfunction H(t) {\n  const e = bt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(H) : H(r));\n  }\n  return e;\n}\nfunction Te(t) {\n  return `tapps/${t}`;\n}\nfunction Le(t, e) {\n  sessionStorage.setItem(Te(t), JSON.stringify(e));\n}\nfunction ht(t) {\n  const e = sessionStorage.getItem(Te(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction mt(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((n) => {\n        n();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction gt(t, e) {\n  e || (e = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: s\n  } = e, a = s === void 0 ? !0 : s, i = typeof a == \"boolean\" ? () => a : a;\n  function u(o, c, ...p) {\n    if (c || i()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[o](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,\n        `${l};background-color: lightblue;color:black`,\n        \"\",\n        `${l};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...p\n      );\n    }\n  }\n  return [u.bind(void 0, \"log\"), u.bind(void 0, \"error\")];\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ie(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? void 0,\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? void 0,\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? void 0\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction vt(t, e) {\n  var n;\n  return (n = void 0) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction wt(t) {\n  var e, n;\n  const r = typeof t;\n  return r === \"string\" ? `\"${t}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${t}` : r === \"object\" || r === \"function\" ? (t && ((n = (e = Object.getPrototypeOf(t)) == null ? void 0 : e.constructor) == null ? void 0 : n.name)) ?? \"null\" : r;\n}\nfunction m(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ wt(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ vt(t.reference, o.lang) ?? (c ? (o.lang, void 0) : null) ?? r.message ?? (o.lang, void 0);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Ie());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction We(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction Et(t, e) {\n  const n = [...new Set(t)];\n  return n.length > 1 ? `(${n.join(` ${e} `)})` : n[0] ?? \"never\";\n}\nvar kt = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction De(t, e) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: De,\n    async: !1,\n    expects: null,\n    requirement: t,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && m(this, \"input\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Re(t) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: Re,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: t,\n    \"~run\"(e, n) {\n      return e.typed && !this.requirement(e.value) && m(this, \"integer\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: x,\n    async: !1,\n    operation: t,\n    \"~run\"(e) {\n      return e.value = this.operation(e.value), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ne(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction xt(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: L,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ce(t) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: Ce,\n    expects: \"Date\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return e.value instanceof Date ? isNaN(e.value) ? m(this, \"type\", e, n, {\n        received: '\"Invalid Date\"'\n      }) : e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ue(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: Ue,\n    expects: t.name,\n    async: !1,\n    class: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof this.class ? n.typed = !0 : m(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ee(t) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: ee,\n    expects: \"unknown\",\n    async: !1,\n    getter: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return this.getter(e.value)[\"~run\"](e, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: q,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      var s;\n      const a = n.value;\n      if (a && typeof a == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in a || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in a ? (\n              // @ts-expect-error\n              a[i]\n            ) : /* @__PURE__ */ Ne(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: a,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (s = n.issues) == null || s.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (m(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: a,\n                key: i,\n                // @ts-expect-error\n                value: a[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in a)\n            /* @__PURE__ */ We(a, i) && !(i in this.entries) && (n.value[i] = a[i]);\n      } else\n        m(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: R,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: _,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Ne(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Oe(t, e, n) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: Oe,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(r, s) {\n      var a, i;\n      const u = r.value;\n      if (u && typeof u == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ We(u, o)) {\n            const c = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of p.issues)\n                b.path = [y], (a = r.issues) == null || a.push(b);\n              if (r.issues || (r.issues = p.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            const l = this.value[\"~run\"](\n              { value: c },\n              s\n            );\n            if (l.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of l.issues)\n                b.path ? b.path.unshift(y) : b.path = [y], (i = r.issues) == null || i.push(b);\n              if (r.issues || (r.issues = l.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !l.typed) && (r.typed = !1), p.typed && (r.value[p.value] = l.value);\n          }\n      } else\n        m(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: d,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction de(t) {\n  let e;\n  if (t)\n    for (const n of t)\n      e ? e.push(...n.issues) : e = n.issues;\n  return e;\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: te,\n    expects: /* @__PURE__ */ Et(\n      t.map((n) => n.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      let s, a, i;\n      for (const u of this.options) {\n        const o = u[\"~run\"]({ value: n.value }, r);\n        if (o.typed)\n          if (o.issues)\n            a ? a.push(o) : a = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (a) {\n        if (a.length === 1)\n          return a[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ de(a)\n        }), n.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ de(i)\n        });\n      }\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Je() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: Je,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction ze(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Ie(n));\n  if (r.issues)\n    throw new kt(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction $t(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction Pt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[$t(n)] = r, e), {});\n}\nfunction Q(t) {\n  const e = Pt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(Q) : Q(r));\n  }\n  return e;\n}\nfunction ne(t) {\n  return /* @__PURE__ */ x((e) => t ? Q(e) : e);\n}\nfunction Ge(t) {\n  return (e) => /* @__PURE__ */ $(\n    t,\n    ne(e)\n  );\n}\nfunction St(t) {\n  return (e, n) => ze(\n    /* @__PURE__ */ $(t, ne(n)),\n    e\n  );\n}\nfunction re() {\n  return /* @__PURE__ */ x(JSON.parse);\n}\nfunction se(t) {\n  const e = Ge(t);\n  return (n) => /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    re(),\n    e(n)\n  );\n}\nfunction jt(t) {\n  return /* @__PURE__ */ x((e) => {\n    const n = {};\n    return new URLSearchParams(e).forEach((r, s) => {\n      const a = n[s];\n      Array.isArray(a) ? a.push(r) : a === void 0 ? n[s] = r : n[s] = [a, r];\n    }), ze(t, n);\n  });\n}\nfunction Be(t) {\n  return (e) => /* @__PURE__ */ $(\n    /* @__PURE__ */ te([/* @__PURE__ */ d(), /* @__PURE__ */ Ue(URLSearchParams)]),\n    jt(t),\n    ne(e)\n  );\n}\nconst _e = /* @__PURE__ */ _(/* @__PURE__ */ ee(() => Lt())), At = /* @__PURE__ */ q({\n  id: /* @__PURE__ */ R(),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  type: /* @__PURE__ */ d(),\n  title: /* @__PURE__ */ d(),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), qt = /* @__PURE__ */ q({\n  added_to_attachment_menu: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  allows_write_to_pm: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  first_name: /* @__PURE__ */ d(),\n  id: /* @__PURE__ */ R(),\n  is_bot: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  is_premium: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  last_name: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  language_code: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), Mt = /* @__PURE__ */ q({\n  auth_date: /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ x((t) => new Date(Number(t) * 1e3)),\n    /* @__PURE__ */ Ce()\n  ),\n  can_send_after: /* @__PURE__ */ _(/* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x(Number), /* @__PURE__ */ Re())),\n  chat: /* @__PURE__ */ _(/* @__PURE__ */ ee(() => Tt())),\n  chat_type: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  chat_instance: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  hash: /* @__PURE__ */ d(),\n  query_id: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  receiver: _e,\n  start_param: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  signature: /* @__PURE__ */ d(),\n  user: _e\n}), Tt = se(At), Lt = se(qt), It = Be(Mt);\nfunction Wt(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nconst Fe = Ge(\n  /* @__PURE__ */ Oe(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ $(\n      /* @__PURE__ */ te([/* @__PURE__ */ d(), /* @__PURE__ */ R()]),\n      /* @__PURE__ */ x((t) => typeof t == \"number\" ? `#${(t & 16777215).toString(16).padStart(6, \"0\")}` : t),\n      /* @__PURE__ */ De(Wt)\n    )\n  )\n), J = /* @__PURE__ */ _(\n  /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x((t) => t === \"1\"))\n), ye = se(Fe()), Dt = /* @__PURE__ */ q({\n  tgWebAppBotInline: J,\n  tgWebAppData: /* @__PURE__ */ _(It()),\n  tgWebAppDefaultColors: /* @__PURE__ */ _(ye()),\n  tgWebAppFullscreen: J,\n  tgWebAppPlatform: /* @__PURE__ */ d(),\n  tgWebAppShowSettings: J,\n  tgWebAppStartParam: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  tgWebAppThemeParams: ye(),\n  tgWebAppVersion: /* @__PURE__ */ d()\n}), Ke = Be(Dt), Rt = St(Ke()), Ye = /* @__PURE__ */ q({\n  eventType: /* @__PURE__ */ d(),\n  eventData: /* @__PURE__ */ _(/* @__PURE__ */ Je())\n});\nfunction He(t, e) {\n  return e || (e = (n, r) => JSON.stringify(r)), new URLSearchParams(\n    Object.entries(t).reduce((n, [r, s]) => (Array.isArray(s) ? n.push(...s.map((a) => [r, String(a)])) : s != null && n.push([\n      r,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : e(r, s)\n    ]), n), [])\n  ).toString();\n}\nfunction Nt(t) {\n  return He(t);\n}\nfunction Ct(t) {\n  return He(t, (e, n) => e === \"tgWebAppData\" ? Nt(n) : JSON.stringify(n));\n}\nfunction Qe(t) {\n  try {\n    return /* @__PURE__ */ xt(Ke(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction Ut(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, n) {\n    var r = t.get(e);\n    r ? r.push(n) : t.set(e, [n]);\n  }, off: function(e, n) {\n    var r = t.get(e);\n    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, n) {\n    var r = t.get(e);\n    r && r.slice().map(function(s) {\n      s(n);\n    }), (r = t.get(\"*\")) && r.slice().map(function(s) {\n      s(e, n);\n    });\n  } };\n}\nfunction Ot(t, e) {\n  const n = Ut(), r = /* @__PURE__ */ new Map(), s = (a, i, u) => {\n    u || (u = !1);\n    const o = r.get(a) || /* @__PURE__ */ new Map();\n    r.set(a, o);\n    const c = o.get(i) || [];\n    o.set(i, c);\n    const p = c.findIndex((l) => l[1] === u);\n    p >= 0 && (n.off(a, c[p][0]), c.splice(p, 1), !c.length && o.delete(i), o.size || (r.delete(a), !r.size && e()));\n  };\n  return [\n    function(i, u, o) {\n      !r.size && t();\n      function c() {\n        s(i, u, o);\n      }\n      function p(...b) {\n        o && c(), i === \"*\" ? u(b) : u(...b);\n      }\n      n.on(i, p);\n      const l = r.get(i) || /* @__PURE__ */ new Map();\n      r.set(i, l);\n      const y = l.get(u) || [];\n      return l.set(u, y), y.push([p, o || !1]), c;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    n.emit,\n    function() {\n      const i = n.all.size;\n      n.all.clear(), r.clear(), i && e();\n    }\n  ];\n}\nfunction be(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet W = !1;\nconst [ie, Jt] = /* @__PURE__ */ gt(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return W;\n  }\n}), he = (t) => {\n  ie(!1, \"Event received:\", t);\n};\nfunction zt(t) {\n  t !== W && (W = t, W ? Ze(\"*\", he) : Bt(\"*\", he));\n}\nconst Gt = {\n  clipboard_text_received: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    data: /* @__PURE__ */ T(/* @__PURE__ */ k())\n  }),\n  custom_method_invoked: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    result: /* @__PURE__ */ F(/* @__PURE__ */ $e()),\n    error: /* @__PURE__ */ F(/* @__PURE__ */ k())\n  }),\n  popup_closed: /* @__PURE__ */ T(\n    /* @__PURE__ */ v({ button_id: /* @__PURE__ */ T(/* @__PURE__ */ k(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: /* @__PURE__ */ v({\n    height: /* @__PURE__ */ B(),\n    width: /* @__PURE__ */ T(/* @__PURE__ */ B(), () => window.innerWidth),\n    is_state_stable: /* @__PURE__ */ G(),\n    is_expanded: /* @__PURE__ */ G()\n  }),\n  theme_changed: /* @__PURE__ */ v({\n    theme_params: Fe()\n  })\n};\nfunction me(t) {\n  if (t.source !== window.parent)\n    return;\n  let e;\n  try {\n    e = K(/* @__PURE__ */ Pe(/* @__PURE__ */ k(), re(), Ye), t.data);\n  } catch {\n    return;\n  }\n  const { eventType: n, eventData: r } = e, s = Gt[n];\n  try {\n    const a = s ? K(s, r) : r;\n    Ft(n, a);\n  } catch (a) {\n    Jt(\n      !0,\n      [\n        `An error occurred processing the \"${n}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      e,\n      a\n    );\n  }\n}\nconst [\n  Ze,\n  Bt,\n  Ft,\n  Kt\n] = Ot(\n  () => {\n    const t = window, e = { receiveEvent: be };\n    t.TelegramGameProxy_receiveEvent = be, t.TelegramGameProxy = e, t.Telegram = { WebView: e }, window.addEventListener(\"message\", me);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n      delete window[t];\n    }), window.removeEventListener(\"message\", me);\n  }\n);\nfunction Yt(t) {\n  return (e) => e instanceof t;\n}\nfunction M(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, Yt(n)];\n}\nconst [\n  Ht,\n  ln\n] = M(\n  \"MethodUnsupportedError\",\n  (t, e) => [\n    `Method \"${t}\" is unsupported in Mini Apps version ${e}`\n  ]\n), [\n  Qt,\n  fn\n] = M(\n  \"MethodParameterUnsupportedError\",\n  (t, e, n) => [\n    `Parameter \"${e}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n  ]\n), Zt = [\n  \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n  \"📖 Refer to docs for more information:\",\n  \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\"\n].join(`\n`), [\n  Xt,\n  dn\n] = M(\"LaunchParamsRetrieveError\", Zt), [\n  Vt,\n  _n\n] = M(\"InvalidLaunchParamsError\", (t) => [\n  `Invalid value for launch params: ${t}`\n]), [en, yn] = M(\"UnknownEnvError\"), [\n  tn,\n  bn\n] = M(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n);\nfunction nn(t, e) {\n  e();\n}\n// @__NO_SIDE_EFFECTS__\nfunction rn(t, e) {\n  e || (e = {});\n  const n = e.equals || Object.is;\n  let r = [], s = t;\n  const a = (c) => {\n    if (!n(s, c)) {\n      const p = s;\n      s = c, nn(o, () => {\n        [...r].forEach(([l, y]) => {\n          l(c, p), y && u(l, !0);\n        });\n      });\n    }\n  };\n  function i(c) {\n    const p = typeof c != \"object\" ? { once: c } : c;\n    return {\n      once: p.once || !1,\n      signal: p.signal || !1\n    };\n  }\n  const u = (c, p) => {\n    const l = i(p), y = r.findIndex(([b, P]) => b === c && P.once === l.once && P.signal === l.signal);\n    y >= 0 && r.splice(y, 1);\n  }, o = Object.assign(\n    function() {\n      return sn(o), s;\n    },\n    {\n      destroy() {\n        r = [];\n      },\n      set: a,\n      reset() {\n        a(t);\n      },\n      sub(c, p) {\n        return r.push([c, i(p)]), () => u(c, p);\n      },\n      unsub: u,\n      unsubAll() {\n        r = r.filter((c) => c[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst z = [];\nfunction sn(t) {\n  z.length && z[z.length - 1].add(t);\n}\nconst Z = /* @__PURE__ */ rn(\"https://web.telegram.org\");\nfunction Xe(t, e) {\n  ie(!1, \"Posting event:\", e ? { eventType: t, eventData: e } : { eventType: t });\n  const n = window, r = JSON.stringify({ eventType: t, eventData: e });\n  if (je())\n    return n.parent.postMessage(r, Z());\n  if (Se(n)) {\n    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));\n    return;\n  }\n  if (/* @__PURE__ */ D(/* @__PURE__ */ v({ external: /* @__PURE__ */ v({ notify: /* @__PURE__ */ V() }) }), n)) {\n    n.external.notify(r);\n    return;\n  }\n  throw new en();\n}\nfunction Ve(t, e, n) {\n  n || (n = {});\n  const { capture: r } = n, [s, a] = mt();\n  return new Me((i) => {\n    (Array.isArray(e) ? e : [e]).forEach((u) => {\n      s(\n        Ze(u, (o) => {\n          (!r || (Array.isArray(e) ? r({\n            event: u,\n            payload: o\n          }) : r(o))) && i(o);\n        })\n      );\n    }), (n.postEvent || Xe)(t, n.params);\n  }, n).finally(a);\n}\nconst ge = \"launchParams\";\nfunction ve(t) {\n  return t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction et() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    () => ve(window.location.href),\n    // Then, try using the lower level API - window.performance.\n    () => {\n      const e = performance.getEntriesByType(\"navigation\")[0];\n      return e && ve(e.name);\n    },\n    () => ht(ge)\n  ]) {\n    const e = t();\n    if (e && Qe(e))\n      return Le(ge, e), e;\n  }\n  throw new Xt();\n}\nfunction an(t) {\n  const e = Rt(et());\n  return t ? H(e) : e;\n}\nfunction hn(t, e) {\n  if (!t)\n    try {\n      return an(), !0;\n    } catch {\n      return !1;\n    }\n  return Me.fn(async (n) => {\n    if (Se(window))\n      return !0;\n    try {\n      return await Ve(\"web_app_request_theme\", \"theme_changed\", n), !0;\n    } catch {\n      return !1;\n    }\n  }, e || { timeout: 100 });\n}\nfunction mn({ launchParams: t, onEvent: e } = {}) {\n  if (t) {\n    const s = typeof t == \"string\" || t instanceof URLSearchParams ? t.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ct({ ...t, tgWebAppData: void 0 }) + (t.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(t.tgWebAppData.toString())}` : \"\")\n    );\n    if (!Qe(s))\n      throw new Vt(s);\n    Le(\"launchParams\", s);\n  }\n  if (je()) {\n    const s = /* @__PURE__ */ Pe(\n      /* @__PURE__ */ k(),\n      re(),\n      Ye\n    ), a = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (...i) => {\n      const [u] = i, o = () => {\n        a(...i);\n      };\n      if (/* @__PURE__ */ D(s, u) && e) {\n        const c = K(s, u);\n        e([c.eventType, c.eventData], o);\n      } else\n        o();\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, { postEvent: r } = n;\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(s, a) {\n      const i = () => {\n        r && r(s, a);\n      };\n      e ? e([s, a ? JSON.parse(a) : void 0], i) : i();\n    }\n  }, ie(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction gn() {\n  return new URLSearchParams(et()).get(\"tgWebAppData\") || void 0;\n}\nfunction on(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction we(t) {\n  return t.split(\".\").map(Number);\n}\nfunction un(t, e) {\n  const n = we(t), r = we(e), s = Math.max(n.length, r.length);\n  for (let a = 0; a < s; a += 1) {\n    const i = n[a] || 0, u = r[a] || 0;\n    if (i !== u)\n      return i > u ? 1 : -1;\n  }\n  return 0;\n}\nfunction h(t, e) {\n  return un(t, e) <= 0;\n}\nfunction Ee(t, e, n) {\n  if (typeof n == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return h(\"6.4\", n);\n      if (e === \"try_browser\")\n        return h(\"7.6\", n);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return h(\"6.9\", n);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return h(\"7.6\", n);\n    if (t === \"web_app_setup_main_button\" && e === \"has_shine_effect\")\n      return h(\"7.10\", n);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return h(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return h(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return h(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return h(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return h(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return h(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return h(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return h(\"7.7\", e);\n    case \"web_app_share_to_story\":\n      return h(\"7.8\", e);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return h(\"7.10\", e);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return h(\"8.0\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction vn(t, e) {\n  e || (e = \"strict\");\n  const n = typeof e == \"function\" ? e : (r) => {\n    const { method: s, version: a } = r, i = \"param\" in r ? new Qt(s, r.param, a) : new Ht(s, a);\n    if (e === \"strict\")\n      throw i;\n    return console.warn(i.message);\n  };\n  return (r, s) => Ee(r, t) ? r === \"web_app_set_header_color\" && /* @__PURE__ */ D(/* @__PURE__ */ v({ color: /* @__PURE__ */ xe() }), s) && !Ee(r, \"color\", t) ? n({ version: t, method: r, param: \"color\" }) : Xe(r, s) : n({ version: t, method: r });\n}\nfunction wn(t, e, n, r) {\n  return Ve(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...r || {},\n    params: { method: t, params: e, req_id: n },\n    capture: on(n)\n  }).then(({ result: s, error: a }) => {\n    if (a)\n      throw new tn(a);\n    return s;\n  });\n}\nfunction En() {\n  Kt(), zt(!1), Z.unsubAll(), Z.reset();\n}\nexport {\n  Vt as InvalidLaunchParamsError,\n  tn as InvokeCustomMethodError,\n  Xt as LaunchParamsRetrieveError,\n  Qt as MethodParameterUnsupportedError,\n  Ht as MethodUnsupportedError,\n  en as UnknownEnvError,\n  on as captureSameReq,\n  un as compareVersions,\n  vn as createPostEvent,\n  be as emitEvent,\n  Se as hasWebviewProxy,\n  wn as invokeCustomMethod,\n  je as isIframe,\n  _n as isInvalidLaunchParamsError,\n  bn as isInvokeCustomMethodError,\n  dn as isLaunchParamsRetrieveError,\n  fn as isMethodMethodParameterUnsupportedError,\n  ln as isMethodUnsupportedError,\n  hn as isTMA,\n  yn as isUnknownEnvError,\n  mn as mockTelegramEnv,\n  Bt as off,\n  Kt as offAll,\n  Ze as on,\n  Xe as postEvent,\n  Ve as request,\n  En as resetPackageState,\n  an as retrieveLaunchParams,\n  gn as retrieveRawInitData,\n  et as retrieveRawLaunchParams,\n  zt as setDebug,\n  Ee as supports,\n  Z as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_launchParams, launchParams] =\n  createSignalsTuple<PackageLaunchParams>({\n    tgWebAppPlatform: 'unknown',\n    tgWebAppVersion: '0.0',\n  });\n\nexport const version = createComputed(() => launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","var f = Object.defineProperty;\nvar u = (t, r, n) => r in t ? f(t, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[r] = n;\nvar c = (t, r, n) => u(t, typeof r != \"symbol\" ? r + \"\" : r, n);\nfunction i(t) {\n  return (r) => r instanceof t;\n}\nfunction d(t, r) {\n  r || (r = []);\n  class n extends Error {\n    constructor(...e) {\n      const o = typeof r == \"function\" ? r(...e) : typeof r == \"string\" ? [r] : r || [];\n      super(...o), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, i(n)];\n}\nfunction m(t, r, n) {\n  class s extends d(t, n)[0] {\n    constructor(...a) {\n      super(...a);\n      c(this, \"data\");\n      this.data = r(...a);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: t }), [s, i(s)];\n}\nexport {\n  d as errorClass,\n  m as errorClassWithData,\n  i as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","var V = Object.defineProperty;\nvar Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;\nvar y = (n, r, e) => Y(n, typeof r != \"symbol\" ? r + \"\" : r, e);\nfunction $(n) {\n  return (r) => r instanceof n;\n}\nfunction B(n, r) {\n  r || (r = []);\n  class e extends Error {\n    constructor(...o) {\n      const s = typeof r == \"function\" ? r(...o) : typeof r == \"string\" ? [r] : r || [];\n      super(...s), this.name = n;\n    }\n  }\n  return Object.defineProperty(e, \"name\", { value: n }), [e, $(e)];\n}\nconst [k, H] = B(\"CancelledError\", \"Promise was canceled\"), [q, J] = B(\n  \"TimeoutError\",\n  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]\n), D = Symbol(\"Resolved\");\nfunction S(n) {\n  return Array.isArray(n) && n[0] === D;\n}\nfunction z(n) {\n  return [D, n];\n}\nfunction x(n, r) {\n  return n.reject = r.reject, n.abort = r.abort, n;\n}\nclass w extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let d, u;\n      typeof e == \"function\" ? (d = e, u = c) : u = e;\n      const b = [], j = (t) => (...h) => {\n        const p = t(...h);\n        return b.forEach((P) => P()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (t) => {\n        !l.aborted && g.abort(t);\n      };\n      const v = () => l.reason, E = (t) => {\n        const h = () => {\n          t(v());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return b.push(p), p;\n      }, F = j((t) => {\n        a(t), s(z(t));\n      });\n      o = j((t) => {\n        i(t), s(t);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: t } = f;\n          if (A)\n            return o(t);\n          s(t);\n        } else {\n          const t = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", t), b.push(() => {\n            f.removeEventListener(\"abort\", t);\n          });\n        }\n      A && E(i);\n      const { timeout: m } = u;\n      if (m) {\n        const t = setTimeout(() => {\n          s(new q(m));\n        }, m);\n        b.push(() => {\n          clearTimeout(t);\n        });\n      }\n      const L = () => l.aborted, T = () => S(v()), C = () => {\n        const t = v();\n        return S(t) ? t[1] : void 0;\n      };\n      try {\n        const t = d && d(F, o, {\n          abortReason: v,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: T,\n          onAborted: E,\n          onResolved: (h) => E(() => {\n            T() && h(C());\n          }),\n          resolved: C,\n          throwIfAborted() {\n            if (L())\n              throw v();\n          }\n        });\n        t instanceof Promise && t.catch(o);\n      } catch (t) {\n        o(t);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new w(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new w((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new k());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(n, r) {\n  return n.resolve = r.resolve, n;\n}\nclass R extends w {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, d, u) => {\n      a = i, o && o(i, d, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  w as AbortablePromise,\n  k as CancelledError,\n  R as ManualPromise,\n  q as TimeoutError,\n  H as isCancelledError,\n  S as isPromiseResolveResult,\n  J as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","import { AbortablePromise } from 'better-promises';\nimport { array, check, parse, pipe, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      return parse(\n        record(\n          pipe(string(), check(v => keys.includes(v))),\n          string(),\n        ),\n        data,\n      );\n    })\n    : AbortablePromise.resolve(typeof keyOrKeys === 'string' ? '' : {});\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ U(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ W(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ N(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ d((n) => e ? w(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ v(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ v(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ d((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ v(\n    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ E(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ E(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ z()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: Q,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: Q\n}), ye = C(le), he = C(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ V(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v(\n      /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ E()]),\n      /* @__PURE__ */ d((e) => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e),\n      /* @__PURE__ */ L(H)\n    )\n  )\n), x = /* @__PURE__ */ c(\n  /* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d((e) => e === \"1\"))\n), G = C(be()), de = /* @__PURE__ */ k({\n  tgWebAppBotInline: x,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(G()),\n  tgWebAppFullscreen: x,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: x,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: G(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(de), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  de as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  C as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  ve as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_request_theme', 'theme_changed', options).then(d => d.theme_params);\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport { isRGB } from '@telegram-apps/transformers';\nimport type { BackgroundColor, BottomBarColor } from '@telegram-apps/bridge';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  backgroundColor as themeBgColor,\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  bottomBarBgColor as themeBottomBarBgColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { HeaderColor, State } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nfunction rgbBasedOn(signal: Computed<'bg_color' | 'secondary_bg_color' | RGB>) {\n  return createComputed<RGB | undefined>(() => {\n    const color = signal();\n\n    return isRGB(color) ? color : color === 'bg_color'\n      ? themeBgColor()\n      : themeSecondaryBgColor();\n  });\n}\n\n/**\n * The Mini App background color.\n */\nexport const [_backgroundColor, backgroundColor] =\n  createSignalsTuple<BackgroundColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] =\n  createSignalsTuple<BottomBarColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    : color === 'bottom_bar_bg_color'\n      // Following the logic from the Telegram SDK.\n      // I removed \"|| '#ffffff'\" because this seems too strange to me. This is just not right.\n      ? themeBottomBarBgColor() || themeSecondaryBgColor()\n      : color === 'secondary_bg_color'\n        ? themeSecondaryBgColor()\n        : themeBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<HeaderColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type BottomBarColor,\n  type BackgroundColor,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { version, postEvent } from '@/globals.js';\nimport { mount as mountThemeParams } from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { GetCssVarNameFn, HeaderColor, State } from './types.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport { RGB } from '@telegram-apps/types';\n\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: BackgroundColor): void => {\n    if (color !== _backgroundColor()) {\n      postEvent(SET_BG_COLOR_METHOD, { color });\n      _backgroundColor.set(color);\n      saveState();\n    }\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: BottomBarColor) => {\n    if (color !== _bottomBarColor()) {\n      postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color });\n      _bottomBarColor.set(color);\n      saveState();\n    }\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: HeaderColor): void => {\n    if (color !== _headerColor()) {\n      postEvent(SET_HEADER_COLOR_METHOD, isRGB(color) ? { color } : { color_key: color });\n      _headerColor.set(color);\n      saveState();\n    }\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { OpenOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn((options: OpenOptions) => {\n  return request(OPEN_METHOD, 'popup_closed', {\n    ...options,\n    params: prepareParams(options),\n  }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n}, 'A popup is already opened');\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n  };\n  auth_date: Date;\n  hash: string;\n}\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContact> {\n  const data = await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  });\n\n  return parse(\n    pipe(\n      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n      union([string(), instance(URLSearchParams)]),\n      transformQueryUsing(\n        looseObject({\n          contact: pipe(\n            string(),\n            jsonParse(),\n            looseObject({\n              user_id: number(),\n              phone_number: string(),\n              first_name: string(),\n              last_name: optional(string()),\n            }),\n          ),\n          auth_date: pipe(\n            string(),\n            transform(input => new Date(Number(input) * 1000)),\n            date(),\n          ),\n          hash: string(),\n        }),\n      ),\n    ),\n    data,\n  );\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return new AbortablePromise<RequestedContact>(async (res, _, context) => {\n      // First of all, let's try to get the requested contact. Probably, we already requested it\n      // before.\n      try {\n        return res(await getRequestedContact(context));\n      } catch (e) {\n        if (e instanceof ValiError) {\n          throw e;\n        }\n      }\n\n      // Then, request access to the user's phone.\n      const status = await requestPhoneAccess(context);\n      if (status !== 'sent') {\n        throw new AccessDeniedError('User denied access');\n      }\n\n      // Time to wait before executing the next request.\n      let sleepTime = 50;\n\n      // We are trying to retrieve the requested contact until the deadline was reached.\n      while (!context.isAborted()) {\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Sleep for some time.\n        await sleep(sleepTime);\n\n        // Increase the sleep time not to kill the backend service.\n        sleepTime += 50;\n      }\n    }, options);\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe('requestContact', fn, {\n  isSupported: 'web_app_request_phone',\n});\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { launchParams, postEvent } from '@/globals.js';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent('web_app_data_send', { data });\n  },\n  {\n    isSupported() {\n      return launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    },\n  },\n);","import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["ke","t","rt","st","it","e","at","n","r","A","a","i","o","c","w","ot","ut","X","D","xe","G","V","v","s","l","T","B","F","k","$e","K","Pe","Se","je","ct","pt","pe","lt","Ae","ft","cn","dt","pn","qe","le","_t","fe","Me","Y","j","I","nt","y","b","P","tt","S","ae","N","oe","ue","ce","yt","bt","H","Te","Le","ht","mt","gt","Ie","vt","wt","m","g","We","Et","kt","De","Re","x","Ne","xt","L","Ce","Ue","ee","q","R","_","Oe","d","de","te","Je","ze","$","$t","Pt","Q","ne","Ge","St","re","se","jt","Be","_e","Lt","At","qt","Mt","Tt","It","Wt","Fe","J","ye","Dt","Ke","Rt","Ye","He","Nt","Ct","Qe","Ut","Ot","u","p","be","W","ie","Jt","he","zt","Ze","Bt","Gt","me","Ft","Kt","Yt","M","Ht","ln","Qt","fn","Zt","Xt","dn","Vt","_n","en","yn","tn","bn","nn","rn","sn","z","Z","Xe","Ve","ge","ve","et","an","hn","mn","gn","on","we","un","h","Ee","vn","wn","C","f","createSignal","initialValue","options","signal","createComputed","computed","createSignalsTuple","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_launchParams","launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","ShareMessageError","isShareMessageError","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","offClick","off","show","unmount","E","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","defineMountFn","onMounted","rest","data","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","createWrapMounted","createWrapBasic","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","wrapBasic","disableConfirmation","setClosingConfirmation","enableConfirmation","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","_b","_addIssue","label","dataset","other","expected","received","issue","isSchema","_getStandardProps","value2","_isValidObjectKey","object2","key","_joinExpects","values","separator","list","ValiError","issues","check","requirement","integer","transform","operation","getDefault","schema","array","itemDataset","pathItem","date","instance","class_","looseObject","entries","valueSchema","valueDataset","number","optional","wrapped","default_","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","validDataset","typedDatasets","untypedDatasets","optionDataset","parse","pipe","pipe2","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","getItem","getKeys","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","CHECK_LOCATION_METHOD","OPEN_SETTINGS_METHOD","isAccessGranted","isAccessRequested","reqLocationFn","tReqLocationPromise","tReqLocationError","requestLocation","requestLocationPromise","isRequestingLocation","requestLocationError","removeUndefined","result","U","O","isColorDark","color","rgb","toRGB","acc","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","rgbBasedOn","isRGB","themeBgColor","themeSecondaryBgColor","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeBottomBarBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","ready","prepareParams","title","buttons","id","OPEN_METHOD","buttonId","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tPromise","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","getRequestedContact","transformQueryUsing","jsonParse","res","sleepTime","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","fallback","textArea","copyTextToClipboard","clipboard","downloadFile","fileName","response","getCurrentTime","readTextFromClipboard","reqId","captureSameReq","sendData","size","shareMessage","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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","x_google_ignoreList":[8,16,27]}