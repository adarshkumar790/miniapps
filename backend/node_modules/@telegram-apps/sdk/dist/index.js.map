{"version":3,"file":"index.js","sources":["../../bridge/dist/index.js","../../toolkit/dist/index.js","../../navigation/dist/index.js","../../signals/dist/index.js","../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../../../node_modules/.pnpm/error-kid@0.0.4/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../../../node_modules/.pnpm/better-promises@0.4.0/node_modules/better-promises/dist/index.js","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/scopes/components/location-manager/location-manager.ts","../src/utils/removeUndefined.ts","../../transformers/dist/index.js","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/copyTextToClipboard.ts","../src/scopes/utilities/uncategorized/downloadFile.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareMessage.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["var E;\n// @__NO_SIDE_EFFECTS__\nfunction ke(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? (E == null ? void 0 : E.lang),\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? (E == null ? void 0 : E.abortEarly),\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? (E == null ? void 0 : E.abortPipeEarly)\n  };\n}\nvar C;\n// @__NO_SIDE_EFFECTS__\nfunction rt(t) {\n  return C == null ? void 0 : C.get(t);\n}\nvar U;\n// @__NO_SIDE_EFFECTS__\nfunction st(t) {\n  return U == null ? void 0 : U.get(t);\n}\nvar O;\n// @__NO_SIDE_EFFECTS__\nfunction it(t, e) {\n  var n;\n  return (n = O == null ? void 0 : O.get(t)) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction at(t) {\n  var n, r;\n  const e = typeof t;\n  return e === \"string\" ? `\"${t}\"` : e === \"number\" || e === \"bigint\" || e === \"boolean\" ? `${t}` : e === \"object\" || e === \"function\" ? (t && ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null ? void 0 : r.name)) ?? \"null\" : e;\n}\nfunction A(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ at(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ it(t.reference, o.lang) ?? (c ? /* @__PURE__ */ st(o.lang) : null) ?? r.message ?? /* @__PURE__ */ rt(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ ke());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ot(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\nvar ut = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction X(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction xe() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: xe,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: G,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: V,\n    expects: \"Function\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"function\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: v,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      var a;\n      const s = n.value;\n      if (s && typeof s == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in s || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ X(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (a = n.issues) == null || a.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (A(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ ot(s, i) && !(i in this.entries) && (n.value[i] = s[i]);\n      } else\n        A(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: T,\n    expects: `(${t.expects} | null | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return (n.value === null || n.value === void 0) && (this.default !== void 0 && (n.value = /* @__PURE__ */ X(this, n, r)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: B,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction F(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: F,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ X(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: k,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction $e() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: $e,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction K(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ ke(n));\n  if (r.issues)\n    throw new ut(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Pe(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction Se(t) {\n  return /* @__PURE__ */ D(\n    /* @__PURE__ */ v({ TelegramWebviewProxy: /* @__PURE__ */ v({ postEvent: /* @__PURE__ */ V() }) }),\n    t\n  );\n}\nfunction je() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar ct = Object.defineProperty, pt = (t, e, n) => e in t ? ct(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, pe = (t, e, n) => pt(t, typeof e != \"symbol\" ? e + \"\" : e, n);\nfunction lt(t) {\n  return (e) => e instanceof t;\n}\nfunction Ae(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, lt(n)];\n}\nconst [ft, cn] = Ae(\"CancelledError\", \"Promise was canceled\"), [dt, pn] = Ae(\n  \"TimeoutError\",\n  (t, e) => [`Timeout reached: ${t}ms`, { cause: e }]\n), qe = Symbol(\"Resolved\");\nfunction le(t) {\n  return Array.isArray(t) && t[0] === qe;\n}\nfunction _t(t) {\n  return [qe, t];\n}\nfunction fe(t, e) {\n  return t.reject = e.reject, t.abort = e.abort, t;\n}\nlet Me = class Y extends Promise {\n  constructor(e, n) {\n    let r, s;\n    super((a, i) => {\n      let u, o;\n      typeof e == \"function\" ? (u = e, o = n) : o = e;\n      const c = [], p = (f) => (...j) => {\n        const I = f(...j);\n        return c.forEach((nt) => nt()), I;\n      }, l = new AbortController(), { signal: y } = l;\n      s = (f) => {\n        !y.aborted && l.abort(f);\n      };\n      const b = () => y.reason, P = (f) => {\n        const j = () => {\n          f(b());\n        };\n        y.addEventListener(\"abort\", j, !0);\n        const I = () => {\n          y.removeEventListener(\"abort\", j, !0);\n        };\n        return c.push(I), I;\n      }, tt = p((f) => {\n        a(f), s(_t(f));\n      });\n      r = p((f) => {\n        i(f), s(f);\n      }), o || (o = {});\n      const { abortSignal: S, rejectOnAbort: ae = !0 } = o;\n      if (S)\n        if (S.aborted) {\n          const { reason: f } = S;\n          if (ae)\n            return r(f);\n          s(f);\n        } else {\n          const f = () => {\n            s(S.reason);\n          };\n          S.addEventListener(\"abort\", f), c.push(() => {\n            S.removeEventListener(\"abort\", f);\n          });\n        }\n      ae && P(i);\n      const { timeout: N } = o;\n      if (N) {\n        const f = setTimeout(() => {\n          s(new dt(N));\n        }, N);\n        c.push(() => {\n          clearTimeout(f);\n        });\n      }\n      const oe = () => y.aborted, ue = () => le(b()), ce = () => {\n        const f = b();\n        return le(f) ? f[1] : void 0;\n      };\n      try {\n        const f = u && u(tt, r, {\n          abortReason: b,\n          abortSignal: y,\n          isAborted: oe,\n          isResolved: ue,\n          onAborted: P,\n          onResolved: (j) => P(() => {\n            ue() && j(ce());\n          }),\n          resolved: ce,\n          throwIfAborted() {\n            if (oe())\n              throw b();\n          }\n        });\n        f instanceof Promise && f.catch(r);\n      } catch (f) {\n        r(f);\n      }\n    }), pe(this, \"abort\"), pe(this, \"reject\"), this.abort = s, this.reject = r;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new Y(async (r, s, a) => {\n      try {\n        r(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new Y((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new ft());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return fe(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return fe(super.then(e, n), this);\n  }\n};\nfunction yt(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction bt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[yt(n)] = r, e), {});\n}\nfunction H(t) {\n  const e = bt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(H) : H(r));\n  }\n  return e;\n}\nfunction Te(t) {\n  return `tapps/${t}`;\n}\nfunction Le(t, e) {\n  sessionStorage.setItem(Te(t), JSON.stringify(e));\n}\nfunction ht(t) {\n  const e = sessionStorage.getItem(Te(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction mt(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((n) => {\n        n();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction gt(t, e) {\n  e || (e = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: s\n  } = e, a = s === void 0 ? !0 : s, i = typeof a == \"boolean\" ? () => a : a;\n  function u(o, c, ...p) {\n    if (c || i()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[o](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,\n        `${l};background-color: lightblue;color:black`,\n        \"\",\n        `${l};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...p\n      );\n    }\n  }\n  return [u.bind(void 0, \"log\"), u.bind(void 0, \"error\")];\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ie(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? void 0,\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? void 0,\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? void 0\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction vt(t, e) {\n  var n;\n  return (n = void 0) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction wt(t) {\n  var e, n;\n  const r = typeof t;\n  return r === \"string\" ? `\"${t}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${t}` : r === \"object\" || r === \"function\" ? (t && ((n = (e = Object.getPrototypeOf(t)) == null ? void 0 : e.constructor) == null ? void 0 : n.name)) ?? \"null\" : r;\n}\nfunction m(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ wt(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ vt(t.reference, o.lang) ?? (c ? (o.lang, void 0) : null) ?? r.message ?? (o.lang, void 0);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Ie());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction We(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction Et(t, e) {\n  const n = [...new Set(t)];\n  return n.length > 1 ? `(${n.join(` ${e} `)})` : n[0] ?? \"never\";\n}\nvar kt = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction De(t, e) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: De,\n    async: !1,\n    expects: null,\n    requirement: t,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && m(this, \"input\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Re(t) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: Re,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: t,\n    \"~run\"(e, n) {\n      return e.typed && !this.requirement(e.value) && m(this, \"integer\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: x,\n    async: !1,\n    operation: t,\n    \"~run\"(e) {\n      return e.value = this.operation(e.value), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ne(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction xt(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: L,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ce(t) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: Ce,\n    expects: \"Date\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return e.value instanceof Date ? isNaN(e.value) ? m(this, \"type\", e, n, {\n        received: '\"Invalid Date\"'\n      }) : e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ue(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: Ue,\n    expects: t.name,\n    async: !1,\n    class: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof this.class ? n.typed = !0 : m(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ee(t) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: ee,\n    expects: \"unknown\",\n    async: !1,\n    getter: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return this.getter(e.value)[\"~run\"](e, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: q,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      var s;\n      const a = n.value;\n      if (a && typeof a == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in a || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in a ? (\n              // @ts-expect-error\n              a[i]\n            ) : /* @__PURE__ */ Ne(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: a,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (s = n.issues) == null || s.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (m(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: a,\n                key: i,\n                // @ts-expect-error\n                value: a[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in a)\n            /* @__PURE__ */ We(a, i) && !(i in this.entries) && (n.value[i] = a[i]);\n      } else\n        m(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: R,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: _,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Ne(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Oe(t, e, n) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: Oe,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(r, s) {\n      var a, i;\n      const u = r.value;\n      if (u && typeof u == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ We(u, o)) {\n            const c = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of p.issues)\n                b.path = [y], (a = r.issues) == null || a.push(b);\n              if (r.issues || (r.issues = p.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            const l = this.value[\"~run\"](\n              { value: c },\n              s\n            );\n            if (l.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of l.issues)\n                b.path ? b.path.unshift(y) : b.path = [y], (i = r.issues) == null || i.push(b);\n              if (r.issues || (r.issues = l.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !l.typed) && (r.typed = !1), p.typed && (r.value[p.value] = l.value);\n          }\n      } else\n        m(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: d,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction de(t) {\n  let e;\n  if (t)\n    for (const n of t)\n      e ? e.push(...n.issues) : e = n.issues;\n  return e;\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: te,\n    expects: /* @__PURE__ */ Et(\n      t.map((n) => n.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      let s, a, i;\n      for (const u of this.options) {\n        const o = u[\"~run\"]({ value: n.value }, r);\n        if (o.typed)\n          if (o.issues)\n            a ? a.push(o) : a = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (a) {\n        if (a.length === 1)\n          return a[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ de(a)\n        }), n.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ de(i)\n        });\n      }\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Je() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: Je,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction ze(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Ie(n));\n  if (r.issues)\n    throw new kt(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction $t(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction Pt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[$t(n)] = r, e), {});\n}\nfunction Q(t) {\n  const e = Pt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(Q) : Q(r));\n  }\n  return e;\n}\nfunction ne(t) {\n  return /* @__PURE__ */ x((e) => t ? Q(e) : e);\n}\nfunction Ge(t) {\n  return (e) => /* @__PURE__ */ $(\n    t,\n    ne(e)\n  );\n}\nfunction St(t) {\n  return (e, n) => ze(\n    /* @__PURE__ */ $(t, ne(n)),\n    e\n  );\n}\nfunction re() {\n  return /* @__PURE__ */ x(JSON.parse);\n}\nfunction se(t) {\n  const e = Ge(t);\n  return (n) => /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    re(),\n    e(n)\n  );\n}\nfunction jt(t) {\n  return /* @__PURE__ */ x((e) => {\n    const n = {};\n    return new URLSearchParams(e).forEach((r, s) => {\n      const a = n[s];\n      Array.isArray(a) ? a.push(r) : a === void 0 ? n[s] = r : n[s] = [a, r];\n    }), ze(t, n);\n  });\n}\nfunction Be(t) {\n  return (e) => /* @__PURE__ */ $(\n    /* @__PURE__ */ te([/* @__PURE__ */ d(), /* @__PURE__ */ Ue(URLSearchParams)]),\n    jt(t),\n    ne(e)\n  );\n}\nconst _e = /* @__PURE__ */ _(/* @__PURE__ */ ee(() => Lt())), At = /* @__PURE__ */ q({\n  id: /* @__PURE__ */ R(),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  type: /* @__PURE__ */ d(),\n  title: /* @__PURE__ */ d(),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), qt = /* @__PURE__ */ q({\n  added_to_attachment_menu: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  allows_write_to_pm: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  first_name: /* @__PURE__ */ d(),\n  id: /* @__PURE__ */ R(),\n  is_bot: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  is_premium: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  last_name: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  language_code: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), Mt = /* @__PURE__ */ q({\n  auth_date: /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ x((t) => new Date(Number(t) * 1e3)),\n    /* @__PURE__ */ Ce()\n  ),\n  can_send_after: /* @__PURE__ */ _(/* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x(Number), /* @__PURE__ */ Re())),\n  chat: /* @__PURE__ */ _(/* @__PURE__ */ ee(() => Tt())),\n  chat_type: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  chat_instance: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  hash: /* @__PURE__ */ d(),\n  query_id: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  receiver: _e,\n  start_param: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  signature: /* @__PURE__ */ d(),\n  user: _e\n}), Tt = se(At), Lt = se(qt), It = Be(Mt);\nfunction Wt(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nconst Fe = Ge(\n  /* @__PURE__ */ Oe(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ $(\n      /* @__PURE__ */ te([/* @__PURE__ */ d(), /* @__PURE__ */ R()]),\n      /* @__PURE__ */ x((t) => typeof t == \"number\" ? `#${(t & 16777215).toString(16).padStart(6, \"0\")}` : t),\n      /* @__PURE__ */ De(Wt)\n    )\n  )\n), J = /* @__PURE__ */ _(\n  /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x((t) => t === \"1\"))\n), ye = se(Fe()), Dt = /* @__PURE__ */ q({\n  tgWebAppBotInline: J,\n  tgWebAppData: /* @__PURE__ */ _(It()),\n  tgWebAppDefaultColors: /* @__PURE__ */ _(ye()),\n  tgWebAppFullscreen: J,\n  tgWebAppPlatform: /* @__PURE__ */ d(),\n  tgWebAppShowSettings: J,\n  tgWebAppStartParam: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  tgWebAppThemeParams: ye(),\n  tgWebAppVersion: /* @__PURE__ */ d()\n}), Ke = Be(Dt), Rt = St(Ke()), Ye = /* @__PURE__ */ q({\n  eventType: /* @__PURE__ */ d(),\n  eventData: /* @__PURE__ */ _(/* @__PURE__ */ Je())\n});\nfunction He(t, e) {\n  return e || (e = (n, r) => JSON.stringify(r)), new URLSearchParams(\n    Object.entries(t).reduce((n, [r, s]) => (Array.isArray(s) ? n.push(...s.map((a) => [r, String(a)])) : s != null && n.push([\n      r,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : e(r, s)\n    ]), n), [])\n  ).toString();\n}\nfunction Nt(t) {\n  return He(t);\n}\nfunction Ct(t) {\n  return He(t, (e, n) => e === \"tgWebAppData\" ? Nt(n) : JSON.stringify(n));\n}\nfunction Qe(t) {\n  try {\n    return /* @__PURE__ */ xt(Ke(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction Ut(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, n) {\n    var r = t.get(e);\n    r ? r.push(n) : t.set(e, [n]);\n  }, off: function(e, n) {\n    var r = t.get(e);\n    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, n) {\n    var r = t.get(e);\n    r && r.slice().map(function(s) {\n      s(n);\n    }), (r = t.get(\"*\")) && r.slice().map(function(s) {\n      s(e, n);\n    });\n  } };\n}\nfunction Ot(t, e) {\n  const n = Ut(), r = /* @__PURE__ */ new Map(), s = (a, i, u) => {\n    u || (u = !1);\n    const o = r.get(a) || /* @__PURE__ */ new Map();\n    r.set(a, o);\n    const c = o.get(i) || [];\n    o.set(i, c);\n    const p = c.findIndex((l) => l[1] === u);\n    p >= 0 && (n.off(a, c[p][0]), c.splice(p, 1), !c.length && o.delete(i), o.size || (r.delete(a), !r.size && e()));\n  };\n  return [\n    function(i, u, o) {\n      !r.size && t();\n      function c() {\n        s(i, u, o);\n      }\n      function p(...b) {\n        o && c(), i === \"*\" ? u(b) : u(...b);\n      }\n      n.on(i, p);\n      const l = r.get(i) || /* @__PURE__ */ new Map();\n      r.set(i, l);\n      const y = l.get(u) || [];\n      return l.set(u, y), y.push([p, o || !1]), c;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    n.emit,\n    function() {\n      const i = n.all.size;\n      n.all.clear(), r.clear(), i && e();\n    }\n  ];\n}\nfunction be(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet W = !1;\nconst [ie, Jt] = /* @__PURE__ */ gt(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return W;\n  }\n}), he = (t) => {\n  ie(!1, \"Event received:\", t);\n};\nfunction zt(t) {\n  t !== W && (W = t, W ? Ze(\"*\", he) : Bt(\"*\", he));\n}\nconst Gt = {\n  clipboard_text_received: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    data: /* @__PURE__ */ T(/* @__PURE__ */ k())\n  }),\n  custom_method_invoked: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    result: /* @__PURE__ */ F(/* @__PURE__ */ $e()),\n    error: /* @__PURE__ */ F(/* @__PURE__ */ k())\n  }),\n  popup_closed: /* @__PURE__ */ T(\n    /* @__PURE__ */ v({ button_id: /* @__PURE__ */ T(/* @__PURE__ */ k(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: /* @__PURE__ */ v({\n    height: /* @__PURE__ */ B(),\n    width: /* @__PURE__ */ T(/* @__PURE__ */ B(), () => window.innerWidth),\n    is_state_stable: /* @__PURE__ */ G(),\n    is_expanded: /* @__PURE__ */ G()\n  }),\n  theme_changed: /* @__PURE__ */ v({\n    theme_params: Fe()\n  })\n};\nfunction me(t) {\n  if (t.source !== window.parent)\n    return;\n  let e;\n  try {\n    e = K(/* @__PURE__ */ Pe(/* @__PURE__ */ k(), re(), Ye), t.data);\n  } catch {\n    return;\n  }\n  const { eventType: n, eventData: r } = e, s = Gt[n];\n  try {\n    const a = s ? K(s, r) : r;\n    Ft(n, a);\n  } catch (a) {\n    Jt(\n      !0,\n      [\n        `An error occurred processing the \"${n}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      e,\n      a\n    );\n  }\n}\nconst [\n  Ze,\n  Bt,\n  Ft,\n  Kt\n] = Ot(\n  () => {\n    const t = window, e = { receiveEvent: be };\n    t.TelegramGameProxy_receiveEvent = be, t.TelegramGameProxy = e, t.Telegram = { WebView: e }, window.addEventListener(\"message\", me);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n      delete window[t];\n    }), window.removeEventListener(\"message\", me);\n  }\n);\nfunction Yt(t) {\n  return (e) => e instanceof t;\n}\nfunction M(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, Yt(n)];\n}\nconst [\n  Ht,\n  ln\n] = M(\n  \"MethodUnsupportedError\",\n  (t, e) => [\n    `Method \"${t}\" is unsupported in Mini Apps version ${e}`\n  ]\n), [\n  Qt,\n  fn\n] = M(\n  \"MethodParameterUnsupportedError\",\n  (t, e, n) => [\n    `Parameter \"${e}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n  ]\n), Zt = [\n  \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n  \"ðŸ“– Refer to docs for more information:\",\n  \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\"\n].join(`\n`), [\n  Xt,\n  dn\n] = M(\"LaunchParamsRetrieveError\", Zt), [\n  Vt,\n  _n\n] = M(\"InvalidLaunchParamsError\", (t) => [\n  `Invalid value for launch params: ${t}`\n]), [en, yn] = M(\"UnknownEnvError\"), [\n  tn,\n  bn\n] = M(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n);\nfunction nn(t, e) {\n  e();\n}\n// @__NO_SIDE_EFFECTS__\nfunction rn(t, e) {\n  e || (e = {});\n  const n = e.equals || Object.is;\n  let r = [], s = t;\n  const a = (c) => {\n    if (!n(s, c)) {\n      const p = s;\n      s = c, nn(o, () => {\n        [...r].forEach(([l, y]) => {\n          l(c, p), y && u(l, !0);\n        });\n      });\n    }\n  };\n  function i(c) {\n    const p = typeof c != \"object\" ? { once: c } : c;\n    return {\n      once: p.once || !1,\n      signal: p.signal || !1\n    };\n  }\n  const u = (c, p) => {\n    const l = i(p), y = r.findIndex(([b, P]) => b === c && P.once === l.once && P.signal === l.signal);\n    y >= 0 && r.splice(y, 1);\n  }, o = Object.assign(\n    function() {\n      return sn(o), s;\n    },\n    {\n      destroy() {\n        r = [];\n      },\n      set: a,\n      reset() {\n        a(t);\n      },\n      sub(c, p) {\n        return r.push([c, i(p)]), () => u(c, p);\n      },\n      unsub: u,\n      unsubAll() {\n        r = r.filter((c) => c[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst z = [];\nfunction sn(t) {\n  z.length && z[z.length - 1].add(t);\n}\nconst Z = /* @__PURE__ */ rn(\"https://web.telegram.org\");\nfunction Xe(t, e) {\n  ie(!1, \"Posting event:\", e ? { eventType: t, eventData: e } : { eventType: t });\n  const n = window, r = JSON.stringify({ eventType: t, eventData: e });\n  if (je())\n    return n.parent.postMessage(r, Z());\n  if (Se(n)) {\n    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));\n    return;\n  }\n  if (/* @__PURE__ */ D(/* @__PURE__ */ v({ external: /* @__PURE__ */ v({ notify: /* @__PURE__ */ V() }) }), n)) {\n    n.external.notify(r);\n    return;\n  }\n  throw new en();\n}\nfunction Ve(t, e, n) {\n  n || (n = {});\n  const { capture: r } = n, [s, a] = mt();\n  return new Me((i) => {\n    (Array.isArray(e) ? e : [e]).forEach((u) => {\n      s(\n        Ze(u, (o) => {\n          (!r || (Array.isArray(e) ? r({\n            event: u,\n            payload: o\n          }) : r(o))) && i(o);\n        })\n      );\n    }), (n.postEvent || Xe)(t, n.params);\n  }, n).finally(a);\n}\nconst ge = \"launchParams\";\nfunction ve(t) {\n  return t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction et() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    () => ve(window.location.href),\n    // Then, try using the lower level API - window.performance.\n    () => {\n      const e = performance.getEntriesByType(\"navigation\")[0];\n      return e && ve(e.name);\n    },\n    () => ht(ge)\n  ]) {\n    const e = t();\n    if (e && Qe(e))\n      return Le(ge, e), e;\n  }\n  throw new Xt();\n}\nfunction an(t) {\n  const e = Rt(et());\n  return t ? H(e) : e;\n}\nfunction hn(t, e) {\n  if (!t)\n    try {\n      return an(), !0;\n    } catch {\n      return !1;\n    }\n  return Me.fn(async (n) => {\n    if (Se(window))\n      return !0;\n    try {\n      return await Ve(\"web_app_request_theme\", \"theme_changed\", n), !0;\n    } catch {\n      return !1;\n    }\n  }, e || { timeout: 100 });\n}\nfunction mn({ launchParams: t, onEvent: e } = {}) {\n  if (t) {\n    const s = typeof t == \"string\" || t instanceof URLSearchParams ? t.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ct({ ...t, tgWebAppData: void 0 }) + (t.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(t.tgWebAppData.toString())}` : \"\")\n    );\n    if (!Qe(s))\n      throw new Vt(s);\n    Le(\"launchParams\", s);\n  }\n  if (je()) {\n    const s = /* @__PURE__ */ Pe(\n      /* @__PURE__ */ k(),\n      re(),\n      Ye\n    ), a = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (...i) => {\n      const [u] = i, o = () => {\n        a(...i);\n      };\n      if (/* @__PURE__ */ D(s, u) && e) {\n        const c = K(s, u);\n        e([c.eventType, c.eventData], o);\n      } else\n        o();\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, { postEvent: r } = n;\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(s, a) {\n      const i = () => {\n        r && r(s, a);\n      };\n      e ? e([s, a ? JSON.parse(a) : void 0], i) : i();\n    }\n  }, ie(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction gn() {\n  return new URLSearchParams(et()).get(\"tgWebAppData\") || void 0;\n}\nfunction on(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction we(t) {\n  return t.split(\".\").map(Number);\n}\nfunction un(t, e) {\n  const n = we(t), r = we(e), s = Math.max(n.length, r.length);\n  for (let a = 0; a < s; a += 1) {\n    const i = n[a] || 0, u = r[a] || 0;\n    if (i !== u)\n      return i > u ? 1 : -1;\n  }\n  return 0;\n}\nfunction h(t, e) {\n  return un(t, e) <= 0;\n}\nfunction Ee(t, e, n) {\n  if (typeof n == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return h(\"6.4\", n);\n      if (e === \"try_browser\")\n        return h(\"7.6\", n);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return h(\"6.9\", n);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return h(\"7.6\", n);\n    if (t === \"web_app_setup_main_button\" && e === \"has_shine_effect\")\n      return h(\"7.10\", n);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return h(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return h(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return h(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return h(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return h(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return h(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return h(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return h(\"7.7\", e);\n    case \"web_app_share_to_story\":\n      return h(\"7.8\", e);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return h(\"7.10\", e);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return h(\"8.0\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction vn(t, e) {\n  e || (e = \"strict\");\n  const n = typeof e == \"function\" ? e : (r) => {\n    const { method: s, version: a } = r, i = \"param\" in r ? new Qt(s, r.param, a) : new Ht(s, a);\n    if (e === \"strict\")\n      throw i;\n    return console.warn(i.message);\n  };\n  return (r, s) => Ee(r, t) ? r === \"web_app_set_header_color\" && /* @__PURE__ */ D(/* @__PURE__ */ v({ color: /* @__PURE__ */ xe() }), s) && !Ee(r, \"color\", t) ? n({ version: t, method: r, param: \"color\" }) : Xe(r, s) : n({ version: t, method: r });\n}\nfunction wn(t, e, n, r) {\n  return Ve(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...r || {},\n    params: { method: t, params: e, req_id: n },\n    capture: on(n)\n  }).then(({ result: s, error: a }) => {\n    if (a)\n      throw new tn(a);\n    return s;\n  });\n}\nfunction En() {\n  Kt(), zt(!1), Z.unsubAll(), Z.reset();\n}\nexport {\n  Vt as InvalidLaunchParamsError,\n  tn as InvokeCustomMethodError,\n  Xt as LaunchParamsRetrieveError,\n  Qt as MethodParameterUnsupportedError,\n  Ht as MethodUnsupportedError,\n  en as UnknownEnvError,\n  on as captureSameReq,\n  un as compareVersions,\n  vn as createPostEvent,\n  be as emitEvent,\n  Se as hasWebviewProxy,\n  wn as invokeCustomMethod,\n  je as isIframe,\n  _n as isInvalidLaunchParamsError,\n  bn as isInvokeCustomMethodError,\n  dn as isLaunchParamsRetrieveError,\n  fn as isMethodMethodParameterUnsupportedError,\n  ln as isMethodUnsupportedError,\n  hn as isTMA,\n  yn as isUnknownEnvError,\n  mn as mockTelegramEnv,\n  Bt as off,\n  Kt as offAll,\n  Ze as on,\n  Xe as postEvent,\n  Ve as request,\n  En as resetPackageState,\n  an as retrieveLaunchParams,\n  gn as retrieveRawInitData,\n  et as retrieveRawLaunchParams,\n  zt as setDebug,\n  Ee as supports,\n  Z as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_launchParams, launchParams] =\n  createSignalsTuple<PackageLaunchParams>({\n    tgWebAppPlatform: 'unknown',\n    tgWebAppVersion: '0.0',\n  });\n\nexport const version = createComputed(() => launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","var f = Object.defineProperty;\nvar u = (t, r, n) => r in t ? f(t, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[r] = n;\nvar c = (t, r, n) => u(t, typeof r != \"symbol\" ? r + \"\" : r, n);\nfunction i(t) {\n  return (r) => r instanceof t;\n}\nfunction d(t, r) {\n  r || (r = []);\n  class n extends Error {\n    constructor(...e) {\n      const o = typeof r == \"function\" ? r(...e) : typeof r == \"string\" ? [r] : r || [];\n      super(...o), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, i(n)];\n}\nfunction m(t, r, n) {\n  class s extends d(t, n)[0] {\n    constructor(...a) {\n      super(...a);\n      c(this, \"data\");\n      this.data = r(...a);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: t }), [s, i(s)];\n}\nexport {\n  d as errorClass,\n  m as errorClassWithData,\n  i as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","var V = Object.defineProperty;\nvar Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;\nvar y = (n, r, e) => Y(n, typeof r != \"symbol\" ? r + \"\" : r, e);\nfunction $(n) {\n  return (r) => r instanceof n;\n}\nfunction B(n, r) {\n  r || (r = []);\n  class e extends Error {\n    constructor(...o) {\n      const s = typeof r == \"function\" ? r(...o) : typeof r == \"string\" ? [r] : r || [];\n      super(...s), this.name = n;\n    }\n  }\n  return Object.defineProperty(e, \"name\", { value: n }), [e, $(e)];\n}\nconst [k, H] = B(\"CancelledError\", \"Promise was canceled\"), [q, J] = B(\n  \"TimeoutError\",\n  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]\n), D = Symbol(\"Resolved\");\nfunction S(n) {\n  return Array.isArray(n) && n[0] === D;\n}\nfunction z(n) {\n  return [D, n];\n}\nfunction x(n, r) {\n  return n.reject = r.reject, n.abort = r.abort, n;\n}\nclass w extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let d, u;\n      typeof e == \"function\" ? (d = e, u = c) : u = e;\n      const b = [], j = (t) => (...h) => {\n        const p = t(...h);\n        return b.forEach((P) => P()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (t) => {\n        !l.aborted && g.abort(t);\n      };\n      const v = () => l.reason, E = (t) => {\n        const h = () => {\n          t(v());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return b.push(p), p;\n      }, F = j((t) => {\n        a(t), s(z(t));\n      });\n      o = j((t) => {\n        i(t), s(t);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: t } = f;\n          if (A)\n            return o(t);\n          s(t);\n        } else {\n          const t = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", t), b.push(() => {\n            f.removeEventListener(\"abort\", t);\n          });\n        }\n      A && E(i);\n      const { timeout: m } = u;\n      if (m) {\n        const t = setTimeout(() => {\n          s(new q(m));\n        }, m);\n        b.push(() => {\n          clearTimeout(t);\n        });\n      }\n      const L = () => l.aborted, T = () => S(v()), C = () => {\n        const t = v();\n        return S(t) ? t[1] : void 0;\n      };\n      try {\n        const t = d && d(F, o, {\n          abortReason: v,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: T,\n          onAborted: E,\n          onResolved: (h) => E(() => {\n            T() && h(C());\n          }),\n          resolved: C,\n          throwIfAborted() {\n            if (L())\n              throw v();\n          }\n        });\n        t instanceof Promise && t.catch(o);\n      } catch (t) {\n        o(t);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new w(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new w((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new k());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(n, r) {\n  return n.resolve = r.resolve, n;\n}\nclass R extends w {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, d, u) => {\n      a = i, o && o(i, d, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  w as AbortablePromise,\n  k as CancelledError,\n  R as ManualPromise,\n  q as TimeoutError,\n  H as isCancelledError,\n  S as isPromiseResolveResult,\n  J as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","import { AbortablePromise } from 'better-promises';\nimport { array, check, parse, pipe, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      return parse(\n        record(\n          pipe(string(), check(v => keys.includes(v))),\n          string(),\n        ),\n        data,\n      );\n    })\n    : AbortablePromise.resolve(typeof keyOrKeys === 'string' ? '' : {});\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ U(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ W(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ N(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ d((n) => e ? w(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ v(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ v(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ d((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ v(\n    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ E(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ E(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ z()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: Q,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: Q\n}), ye = C(le), he = C(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ V(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v(\n      /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ E()]),\n      /* @__PURE__ */ d((e) => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e),\n      /* @__PURE__ */ L(H)\n    )\n  )\n), x = /* @__PURE__ */ c(\n  /* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d((e) => e === \"1\"))\n), G = C(be()), de = /* @__PURE__ */ k({\n  tgWebAppBotInline: x,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(G()),\n  tgWebAppFullscreen: x,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: x,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: G(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(de), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  de as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  C as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  ve as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_request_theme', 'theme_changed', options).then(d => d.theme_params);\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport { isRGB } from '@telegram-apps/transformers';\nimport type { BackgroundColor, BottomBarColor } from '@telegram-apps/bridge';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  backgroundColor as themeBgColor,\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  bottomBarBgColor as themeBottomBarBgColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { HeaderColor, State } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nfunction rgbBasedOn(signal: Computed<'bg_color' | 'secondary_bg_color' | RGB>) {\n  return createComputed<RGB | undefined>(() => {\n    const color = signal();\n\n    return isRGB(color) ? color : color === 'bg_color'\n      ? themeBgColor()\n      : themeSecondaryBgColor();\n  });\n}\n\n/**\n * The Mini App background color.\n */\nexport const [_backgroundColor, backgroundColor] =\n  createSignalsTuple<BackgroundColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] =\n  createSignalsTuple<BottomBarColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    : color === 'bottom_bar_bg_color'\n      // Following the logic from the Telegram SDK.\n      // I removed \"|| '#ffffff'\" because this seems too strange to me. This is just not right.\n      ? themeBottomBarBgColor() || themeSecondaryBgColor()\n      : color === 'secondary_bg_color'\n        ? themeSecondaryBgColor()\n        : themeBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<HeaderColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type BottomBarColor,\n  type BackgroundColor,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { version, postEvent } from '@/globals.js';\nimport { mount as mountThemeParams } from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { GetCssVarNameFn, HeaderColor, State } from './types.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport { RGB } from '@telegram-apps/types';\n\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: BackgroundColor): void => {\n    if (color !== _backgroundColor()) {\n      postEvent(SET_BG_COLOR_METHOD, { color });\n      _backgroundColor.set(color);\n      saveState();\n    }\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: BottomBarColor) => {\n    if (color !== _bottomBarColor()) {\n      postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color });\n      _bottomBarColor.set(color);\n      saveState();\n    }\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: HeaderColor): void => {\n    if (color !== _headerColor()) {\n      postEvent(SET_HEADER_COLOR_METHOD, isRGB(color) ? { color } : { color_key: color });\n      _headerColor.set(color);\n      saveState();\n    }\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { OpenOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn((options: OpenOptions) => {\n  return request(OPEN_METHOD, 'popup_closed', {\n    ...options,\n    params: prepareParams(options),\n  }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n}, 'A popup is already opened');\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n  };\n  auth_date: Date;\n  hash: string;\n}\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContact> {\n  const data = await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  });\n\n  return parse(\n    pipe(\n      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n      union([string(), instance(URLSearchParams)]),\n      transformQueryUsing(\n        looseObject({\n          contact: pipe(\n            string(),\n            jsonParse(),\n            looseObject({\n              user_id: number(),\n              phone_number: string(),\n              first_name: string(),\n              last_name: optional(string()),\n            }),\n          ),\n          auth_date: pipe(\n            string(),\n            transform(input => new Date(Number(input) * 1000)),\n            date(),\n          ),\n          hash: string(),\n        }),\n      ),\n    ),\n    data,\n  );\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return new AbortablePromise<RequestedContact>(async (res, _, context) => {\n      // First of all, let's try to get the requested contact. Probably, we already requested it\n      // before.\n      try {\n        return res(await getRequestedContact(context));\n      } catch (e) {\n        if (e instanceof ValiError) {\n          throw e;\n        }\n      }\n\n      // Then, request access to the user's phone.\n      const status = await requestPhoneAccess(context);\n      if (status !== 'sent') {\n        throw new AccessDeniedError('User denied access');\n      }\n\n      // Time to wait before executing the next request.\n      let sleepTime = 50;\n\n      // We are trying to retrieve the requested contact until the deadline was reached.\n      while (!context.isAborted()) {\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Sleep for some time.\n        await sleep(sleepTime);\n\n        // Increase the sleep time not to kill the backend service.\n        sleepTime += 50;\n      }\n    }, options);\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe('requestContact', fn, {\n  isSupported: 'web_app_request_phone',\n});\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { launchParams, postEvent } from '@/globals.js';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent('web_app_data_send', { data });\n  },\n  {\n    isSupported() {\n      return launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    },\n  },\n);","import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["ke","t","it","e","at","n","r","A","a","i","u","o","p","w","ot","ut","X","D","xe","G","V","v","s","l","T","B","F","k","$e","K","Pe","Se","je","ct","pt","pe","lt","Ae","ft","cn","dt","pn","qe","le","_t","fe","Me","Y","f","I","nt","y","b","P","tt","S","ae","N","oe","ue","ce","yt","bt","H","Te","Le","ht","mt","gt","Ie","vt","wt","m","g","We","Et","kt","De","Re","x","Ne","xt","L","Ce","Ue","ee","q","R","_","Oe","d","de","te","Je","ze","$","$t","Pt","Q","ne","Ge","St","re","se","jt","Be","_e","Lt","At","qt","Mt","Tt","It","Wt","Fe","J","ye","Dt","Ke","Rt","Ye","He","Nt","Ct","Qe","Ut","Ot","c","be","W","ie","Jt","he","zt","Ze","Bt","Gt","me","Ft","Kt","Yt","M","Ht","ln","Qt","fn","Zt","Xt","dn","Vt","_n","en","yn","tn","bn","nn","rn","sn","z","Z","Xe","Ve","ge","ve","et","an","hn","mn","gn","on","we","un","h","Ee","vn","wn","C","j","createSignal","initialValue","options","signal","createComputed","computed","createSignalsTuple","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_launchParams","launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","ShareMessageError","isShareMessageError","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","offClick","off","show","unmount","E","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","defineMountFn","onMounted","rest","data","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","createWrapMounted","createWrapBasic","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","wrapBasic","disableConfirmation","setClosingConfirmation","enableConfirmation","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","_b","_addIssue","label","dataset","other","expected","received","issue","isSchema","_getStandardProps","value2","_isValidObjectKey","object2","key","_joinExpects","values","separator","list","ValiError","issues","check","requirement","integer","transform","operation","getDefault","schema","array","itemDataset","pathItem","date","instance","class_","looseObject","entries","valueSchema","valueDataset","number","optional","wrapped","default_","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","validDataset","typedDatasets","untypedDatasets","optionDataset","parse","pipe","pipe2","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","getItem","getKeys","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","CHECK_LOCATION_METHOD","OPEN_SETTINGS_METHOD","isAccessGranted","isAccessRequested","reqLocationFn","tReqLocationPromise","tReqLocationError","requestLocation","requestLocationPromise","isRequestingLocation","requestLocationError","removeUndefined","result","U","O","isColorDark","color","rgb","toRGB","acc","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","rgbBasedOn","isRGB","themeBgColor","themeSecondaryBgColor","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeBottomBarBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","ready","prepareParams","title","buttons","id","OPEN_METHOD","buttonId","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tPromise","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","getRequestedContact","transformQueryUsing","jsonParse","res","sleepTime","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","fallback","textArea","copyTextToClipboard","clipboard","downloadFile","fileName","response","getCurrentTime","readTextFromClipboard","reqId","captureSameReq","sendData","size","shareMessage","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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","x_google_ignoreList":[8,16,27]}